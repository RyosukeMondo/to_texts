{
  "id": "snapshot_1760713054152_w3imsv0hg",
  "approvalId": "approval_1760712752443_drkgsa4zh",
  "approvalTitle": "Design: Database Storage Feature",
  "version": 2,
  "timestamp": "2025-10-17T14:57:34.152Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe database storage feature adds a persistent SQLite database layer to zlibrary-downloader, enabling local storage and management of book metadata. The design follows a clean three-layer architecture: CLI layer for user interaction, Service layer for business logic, and Repository layer for data access. This architecture maintains strict separation of concerns while integrating seamlessly with the existing codebase patterns (dataclasses, managers, type safety).\n\nThe implementation will be fully additive with no breaking changes - all existing commands continue to work unchanged, and database features are opt-in through new `db` subcommands and a `--save-db` flag.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nWhile no formal tech.md exists yet, this design follows the established patterns in the codebase:\n- **Dataclasses for models**: Following the `Credential` pattern for type-safe data models\n- **Manager classes**: Following `CredentialManager` and `ClientPool` patterns for component management\n- **Enum for status**: Following `CredentialStatus` pattern for type-safe state management\n- **Type hints everywhere**: Complete type annotations matching existing strict mypy configuration\n- **Error handling**: Graceful error handling with clear user messages\n- **Testing patterns**: Using pytest with fixtures following existing `conftest.py` patterns\n\n### Project Structure (structure.md)\n\nThe implementation follows the existing flat structure in `zlibrary_downloader/`:\n- New modules will be added alongside existing ones (`client.py`, `credential.py`, etc.)\n- Database-related code will be in new modules: `db_manager.py`, `models.py`, `repositories.py`, `services.py`\n- Each module stays under 400 lines through focused single-responsibility design\n- Tests mirror the source structure in `tests/` directory\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`Credential` dataclass pattern**: Will create similar dataclasses for `Book`, `Author`, `Download` models\n- **`CredentialManager`**: Pattern for `DatabaseManager` to handle connection lifecycle\n- **CLI argument parsing**: Extend existing `create_argument_parser()` with new `db` subcommand group\n- **`display_results()` function**: Reuse for displaying browse results in familiar format\n- **`conftest.py` fixtures**: Pattern for creating test database fixtures\n- **Type hints style**: Match existing strict typing with `Optional`, `List`, `Dict[str, Any]`\n\n### Integration Points\n\n- **CLI (`cli.py`)**: Add `db` subcommand group; integrate `--save-db` flag into existing `search_books()` function\n- **Search flow**: Hook into `search_books()` to optionally store results after fetching from API\n- **Download flow**: Hook into `download_book()` to automatically record downloads\n- **Client (`client.py`)**: No modifications needed - clean separation through service layer\n- **Credentials**: Reference credentials by ID in download tracking (foreign key relationship)\n\n## Architecture\n\nThe design follows a **clean three-layer architecture** with strict separation of concerns:\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                      CLI Layer (cli.py)                          │\n│  • Argument parsing with argparse                                │\n│  • User input/output                                             │\n│  • Command routing                                               │\n│  • Thin orchestration only                                       │\n└────────────────────────┬────────────────────────────────────────┘\n                         │\n                         ▼\n┌─────────────────────────────────────────────────────────────────┐\n│              Service Layer (services.py modules)                 │\n│  • BookService: Book operations orchestration                    │\n│  • SearchService: Search + storage orchestration                 │\n│  • ListService: Reading list management                          │\n│  • DownloadService: Download tracking                            │\n│  • Business logic and validation                                 │\n│  • No direct SQL - only repository calls                         │\n└────────────────────────┬────────────────────────────────────────┘\n                         │\n                         ▼\n┌─────────────────────────────────────────────────────────────────┐\n│         Repository Layer (repositories.py modules)               │\n│  • BookRepository: Book CRUD + search queries                    │\n│  • AuthorRepository: Author management                           │\n│  • ListRepository: Reading list operations                       │\n│  • DownloadRepository: Download tracking                         │\n│  • SearchHistoryRepository: Search history                       │\n│  • All SQL queries isolated here                                 │\n└────────────────────────┬────────────────────────────────────────┘\n                         │\n                         ▼\n┌─────────────────────────────────────────────────────────────────┐\n│              Database Manager (db_manager.py)                    │\n│  • SQLite connection management                                  │\n│  • Schema initialization                                         │\n│  • Transaction handling                                          │\n│  • Following CredentialManager pattern                           │\n└────────────────────────┬────────────────────────────────────────┘\n                         │\n                         ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                    Data Models (models.py)                       │\n│  • Book, Author, ReadingList, Download dataclasses              │\n│  • Following Credential dataclass pattern                        │\n│  • Immutable, type-safe, serializable                            │\n└─────────────────────────────────────────────────────────────────┘\n                         │\n                         ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                 SQLite Database (~/.zlibrary/books.db)           │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: Each module ≤400 lines, focused on one domain\n- **Component Isolation**: Repositories don't call other repositories directly (service orchestration)\n- **Service Layer Separation**: Services never write SQL - only call repository methods\n- **Utility Modularity**: DB utilities in separate `db_utils.py` (<80 lines)\n\n```mermaid\ngraph TD\n    CLI[CLI: db commands] --> BookSvc[BookService]\n    CLI --> SearchSvc[SearchService]\n    CLI --> ListSvc[ListService]\n    CLI --> DownloadSvc[DownloadService]\n\n    BookSvc --> BookRepo[BookRepository]\n    BookSvc --> AuthorRepo[AuthorRepository]\n    SearchSvc --> BookRepo\n    SearchSvc --> SearchRepo[SearchHistoryRepository]\n    ListSvc --> ListRepo[ListRepository]\n    DownloadSvc --> DownloadRepo[DownloadRepository]\n\n    BookRepo --> DBMgr[DatabaseManager]\n    AuthorRepo --> DBMgr\n    ListRepo --> DBMgr\n    DownloadRepo --> DBMgr\n    SearchRepo --> DBMgr\n\n    DBMgr --> SQLite[(SQLite Database)]\n```\n\n## Components and Interfaces\n\n### Component 1: DatabaseManager (db_manager.py)\n\n- **Purpose:** Manage SQLite connection lifecycle and schema initialization\n- **Interfaces:**\n  ```python\n  class DatabaseManager:\n      def __init__(self, db_path: Optional[Path] = None) -> None\n      def get_connection(self) -> sqlite3.Connection\n      def initialize_schema(self) -> None\n      def close(self) -> None\n      def execute_transaction(self, operations: List[Callable]) -> None\n  ```\n- **Dependencies:** Python stdlib `sqlite3`, `pathlib`\n- **Reuses:** Follows `CredentialManager` pattern for lifecycle management\n- **File size:** ~150 lines\n\n### Component 2: Data Models (models.py)\n\n- **Purpose:** Type-safe dataclasses for all database entities\n- **Interfaces:**\n  ```python\n  @dataclass\n  class Book:\n      id: str  # Z-Library ID (primary key)\n      hash: str\n      title: str\n      year: Optional[str] = None\n      publisher: Optional[str] = None\n      language: Optional[str] = None\n      extension: Optional[str] = None\n      size: Optional[str] = None\n      filesize: Optional[int] = None\n      cover_url: Optional[str] = None\n      description: Optional[str] = None\n      created_at: datetime = field(default_factory=datetime.now)\n      updated_at: datetime = field(default_factory=datetime.now)\n\n  @dataclass\n  class Author:\n      id: Optional[int] = None\n      name: str = \"\"\n\n  @dataclass\n  class ReadingList:\n      id: Optional[int] = None\n      name: str = \"\"\n      description: str = \"\"\n      created_at: datetime = field(default_factory=datetime.now)\n\n  @dataclass\n  class Download:\n      id: Optional[int] = None\n      book_id: str = \"\"\n      credential_id: Optional[int] = None\n      filename: str = \"\"\n      file_path: str = \"\"\n      downloaded_at: datetime = field(default_factory=datetime.now)\n      file_size: Optional[int] = None\n      status: str = \"completed\"\n  ```\n- **Dependencies:** `dataclasses`, `datetime`\n- **Reuses:** Exactly follows `Credential` dataclass pattern\n- **File size:** ~200 lines (simple data structures)\n\n### Component 3: BookRepository (repositories.py)\n\n- **Purpose:** All book-related database operations\n- **Interfaces:**\n  ```python\n  class BookRepository:\n      def __init__(self, db_manager: DatabaseManager) -> None\n      def create(self, book: Book) -> Book\n      def get_by_id(self, book_id: str) -> Optional[Book]\n      def search(self, query: Optional[str] = None, **filters) -> List[Book]\n      def update(self, book: Book) -> Book\n      def upsert(self, book: Book) -> Book  # Insert or update\n      def delete(self, book_id: str) -> bool\n      def count(self, filters: Optional[Dict[str, Any]] = None) -> int\n  ```\n- **Dependencies:** `DatabaseManager`, `Book` model\n- **Reuses:** None (new component)\n- **File size:** ~250 lines (complex queries with parameterization)\n\n### Component 4: SearchService (services.py)\n\n- **Purpose:** Orchestrate search operations with optional database storage\n- **Interfaces:**\n  ```python\n  class SearchService:\n      def __init__(\n          self,\n          book_repo: BookRepository,\n          author_repo: AuthorRepository,\n          search_repo: SearchHistoryRepository\n      ) -> None\n      def search_and_store(\n          self,\n          client: Zlibrary,\n          query: str,\n          **filters\n      ) -> List[Book]\n      def _extract_authors(self, author_str: str) -> List[str]\n      def _store_book(self, book_data: Dict[str, Any]) -> Book\n  ```\n- **Dependencies:** `BookRepository`, `AuthorRepository`, `SearchHistoryRepository`, `Zlibrary` client\n- **Reuses:** Existing `Zlibrary` client from `client.py`\n- **File size:** ~150 lines\n\n### Component 5: CLI Integration (cli.py additions)\n\n- **Purpose:** Add `db` subcommand group and integrate database storage\n- **Interfaces:**\n  ```python\n  def add_db_commands(subparsers) -> None  # New function\n  def db_browse(args, book_service: BookService) -> None  # New\n  def db_show(args, book_service: BookService) -> None  # New\n  def db_save(args, book_service: BookService) -> None  # New\n  def db_list_create(args, list_service: ListService) -> None  # New\n  # ... more db commands\n\n  # Modified to add --save-db flag\n  def search_books(client, query, client_pool, save_to_db=False, search_service=None)\n  ```\n- **Dependencies:** All service classes, existing CLI infrastructure\n- **Reuses:** Existing `create_argument_parser()`, `display_results()`, `argparse` patterns\n- **File size:** Adds ~200 lines to cli.py (keeps total under 400)\n\n## Data Models\n\n### Database Schema\n\n```sql\n-- Books table (core entity)\nCREATE TABLE books (\n    id TEXT PRIMARY KEY,\n    hash TEXT NOT NULL,\n    title TEXT NOT NULL,\n    year TEXT,\n    publisher TEXT,\n    language TEXT,\n    extension TEXT,\n    size TEXT,\n    filesize INTEGER,\n    cover_url TEXT,\n    description TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\nCREATE INDEX idx_books_title ON books(title);\nCREATE INDEX idx_books_language ON books(language);\n\n-- Authors table\nCREATE TABLE authors (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL UNIQUE\n);\n\n-- Book-Author junction table (many-to-many)\nCREATE TABLE book_authors (\n    book_id TEXT NOT NULL,\n    author_id INTEGER NOT NULL,\n    author_order INTEGER DEFAULT 0,\n    PRIMARY KEY (book_id, author_id),\n    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,\n    FOREIGN KEY (author_id) REFERENCES authors(id) ON DELETE CASCADE\n);\n\n-- Reading lists\nCREATE TABLE reading_lists (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL UNIQUE,\n    description TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- List-Book junction table\nCREATE TABLE list_books (\n    list_id INTEGER NOT NULL,\n    book_id TEXT NOT NULL,\n    position INTEGER DEFAULT 0,\n    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (list_id, book_id),\n    FOREIGN KEY (list_id) REFERENCES reading_lists(id) ON DELETE CASCADE,\n    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE\n);\n\n-- Saved books (bookmarks)\nCREATE TABLE saved_books (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    book_id TEXT NOT NULL UNIQUE,\n    notes TEXT,\n    tags TEXT,\n    priority INTEGER DEFAULT 0,\n    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE\n);\n\n-- Download tracking\nCREATE TABLE downloads (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    book_id TEXT NOT NULL,\n    credential_id INTEGER,\n    filename TEXT NOT NULL,\n    file_path TEXT NOT NULL,\n    downloaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    file_size INTEGER,\n    status TEXT DEFAULT 'completed',\n    error_msg TEXT,\n    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE\n);\n\n-- Search history\nCREATE TABLE search_history (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    search_query TEXT NOT NULL,\n    search_filters TEXT,\n    found_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### Data Flow Example: Search and Store\n\n```\n1. User: zlibrary-downloader search \"python\" --save-db\n2. CLI parses args, creates SearchService with repositories\n3. SearchService.search_and_store():\n   a. Calls client.search(\"python\")\n   b. For each book in results:\n      - Extract authors from author string\n      - author_repo.get_or_create(author_name) for each\n      - book_repo.upsert(book)  # Insert or update\n      - Link book to authors in book_authors table\n   c. search_repo.record_search(query, filters)\n4. Returns books to CLI for display\n5. CLI displays results using display_results()\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Database File Creation Fails**\n   - **Handling:** Catch `OSError`, log error, show clear message with required permissions\n   - **User Impact:** \"Failed to create database at ~/.zlibrary/books.db: Permission denied. Please check file permissions.\"\n\n2. **Database Corruption Detected**\n   - **Handling:** Catch `sqlite3.DatabaseError`, offer to recreate schema or restore from backup\n   - **User Impact:** \"Database corruption detected. Options: (1) Recreate database (2) Restore from backup (3) Exit\"\n\n3. **Book ID Not Found**\n   - **Handling:** Return `None` from repository, service checks and raises friendly error\n   - **User Impact:** \"Book ID '12345' not found in database. Try searching: zlibrary-downloader search 'book name' --save-db\"\n\n4. **Duplicate Reading List Name**\n   - **Handling:** Check uniqueness before insert, raise `ValueError` with suggestion\n   - **User Impact:** \"Reading list 'ML Books' already exists. Use a different name or view existing lists with: zlibrary-downloader db lists\"\n\n5. **SQL Query Timeout/Lock**\n   - **Handling:** Set reasonable timeout (5s), retry once, then fail with clear message\n   - **User Impact:** \"Database is temporarily locked. Please try again in a moment.\"\n\n6. **Invalid Import File Format**\n   - **Handling:** Validate JSON structure before processing, rollback transaction on error\n   - **User Impact:** \"Import file is invalid: Expected JSON with 'books' array. No changes made to database.\"\n\n7. **Disk Space Exhausted**\n   - **Handling:** Catch `sqlite3.OperationalError` for disk full, suggest cleanup\n   - **User Impact:** \"Insufficient disk space. Current database: 150MB. Free up space or use --export to backup and clean.\"\n\n## Testing Strategy\n\n### Unit Testing\n\n**Approach**: Test each component in isolation using mocks and in-memory SQLite.\n\n**Key Components to Test:**\n\n1. **DatabaseManager**\n   - Schema initialization creates all tables\n   - get_connection() returns valid connection\n   - close() properly closes connection\n   - Transaction support with rollback on error\n\n2. **Data Models**\n   - Dataclass instantiation with defaults\n   - Serialization/deserialization if added\n\n3. **Repositories**\n   - CRUD operations with in-memory DB\n   - Search with various filter combinations\n   - Upsert logic (insert new, update existing)\n   - Foreign key constraints enforced\n   - Parameterized query injection safety\n\n4. **Services**\n   - search_and_store() with mocked Zlibrary client\n   - Author extraction from various formats\n   - Error handling for database failures\n\n**Test Pattern Example:**\n```python\n@pytest.fixture\ndef in_memory_db():\n    \"\"\"Create in-memory database for testing.\"\"\"\n    db_mgr = DatabaseManager(db_path=\":memory:\")\n    db_mgr.initialize_schema()\n    yield db_mgr\n    db_mgr.close()\n\ndef test_book_repository_create(in_memory_db):\n    repo = BookRepository(in_memory_db)\n    book = Book(id=\"123\", hash=\"abc\", title=\"Test Book\")\n    created = repo.create(book)\n    assert created.id == \"123\"\n\n    # Verify in DB\n    retrieved = repo.get_by_id(\"123\")\n    assert retrieved is not None\n    assert retrieved.title == \"Test Book\"\n```\n\n### Integration Testing\n\n**Approach**: Test end-to-end workflows with real database file (temp directory).\n\n**Key Flows to Test:**\n\n1. **Search and Store Flow**\n   - Mock Z-Library API responses\n   - Run search with --save-db\n   - Verify books in database\n   - Verify authors extracted and linked\n   - Verify search history recorded\n\n2. **Browse Flow**\n   - Populate database with test data\n   - Run browse with various filters\n   - Verify correct results returned\n   - Test pagination\n\n3. **Reading List Flow**\n   - Create list\n   - Add books\n   - View list\n   - Remove books\n   - Delete list\n\n4. **Download Tracking Flow**\n   - Perform download (mocked)\n   - Verify download recorded\n   - Check download history\n\n**Test Pattern Example:**\n```python\ndef test_search_and_store_integration(tmp_path, mock_zlibrary_client):\n    # Setup\n    db_path = tmp_path / \"test.db\"\n    db_mgr = DatabaseManager(db_path)\n    db_mgr.initialize_schema()\n\n    search_service = SearchService(\n        BookRepository(db_mgr),\n        AuthorRepository(db_mgr),\n        SearchHistoryRepository(db_mgr)\n    )\n\n    # Mock API response\n    mock_zlibrary_client.search.return_value = {\n        \"books\": [{\"id\": \"123\", \"title\": \"Test\", \"author\": \"Author\"}]\n    }\n\n    # Execute\n    books = search_service.search_and_store(\n        mock_zlibrary_client,\n        \"python\"\n    )\n\n    # Verify\n    assert len(books) == 1\n    assert books[0].title == \"Test\"\n\n    # Verify in DB\n    book_repo = BookRepository(db_mgr)\n    stored_book = book_repo.get_by_id(\"123\")\n    assert stored_book is not None\n```\n\n### End-to-End Testing\n\n**Approach**: Test actual CLI commands with subprocess calls.\n\n**User Scenarios to Test:**\n\n1. **New User Workflow**\n   - Fresh install\n   - Run search without --save-db (no database created)\n   - Run search with --save-db (database created)\n   - Browse database\n   - Create reading list\n   - Save a book\n\n2. **Power User Workflow**\n   - Bulk searches with storage\n   - Complex filtering\n   - Export database\n   - Import into new database\n   - Verify data integrity\n\n3. **Error Recovery**\n   - Database locked scenario\n   - Corrupt database recovery\n   - Missing book ID error messages\n\n**Test Pattern Example:**\n```python\ndef test_cli_search_and_browse_e2e(tmp_path, monkeypatch):\n    # Set test database location\n    monkeypatch.setenv(\"ZLIBRARY_DB_PATH\", str(tmp_path / \"books.db\"))\n\n    # Mock credentials\n    create_test_credentials(tmp_path)\n\n    # Run search with --save-db\n    result = subprocess.run(\n        [\"zlibrary-downloader\", \"search\", \"python\", \"--save-db\"],\n        capture_output=True,\n        text=True\n    )\n    assert result.returncode == 0\n    assert \"Books found\" in result.stdout\n\n    # Browse database\n    result = subprocess.run(\n        [\"zlibrary-downloader\", \"db\", \"browse\", \"--language\", \"english\"],\n        capture_output=True,\n        text=True\n    )\n    assert result.returncode == 0\n    assert \"python\" in result.stdout.lower()\n```\n\n## Performance Considerations\n\n- **Indexing Strategy**: Create indexes on frequently queried columns (title, language, year)\n- **Bulk Inserts**: Use executemany() for batch operations\n- **Connection Pooling**: Single connection per CLI invocation (short-lived)\n- **Query Optimization**: Use EXPLAIN QUERY PLAN to optimize slow queries\n- **Pagination**: Implement LIMIT/OFFSET for browse results\n- **File Size Management**: Implement VACUUM command for database maintenance\n",
  "fileStats": {
    "size": 23195,
    "lines": 587,
    "lastModified": "2025-10-17T14:52:24.082Z"
  },
  "comments": []
}