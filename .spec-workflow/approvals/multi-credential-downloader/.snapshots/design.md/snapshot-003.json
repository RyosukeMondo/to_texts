{
  "id": "snapshot_1760626476051_mz6ddhhpq",
  "approvalId": "approval_1760626275514_ac7th4yzv",
  "approvalTitle": "Design Document - Multi-Credential Downloader (Revised with TOML)",
  "version": 3,
  "timestamp": "2025-10-16T14:54:36.051Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Multi-Credential Account Downloading feature adds credential rotation capabilities to the Z-Library downloader, enabling transparent management of multiple accounts to maximize download capacity and avoid rate limiting. The design introduces four new modular components that integrate seamlessly with the existing CLI-based architecture while maintaining backward compatibility.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nThis design follows Python best practices:\n- Uses dataclasses for data models (Credential)\n- Implements proper error handling with custom exceptions\n- Follows PEP 8 naming conventions\n- Uses type hints throughout for better code quality\n- Leverages existing patterns from the zlibrary_downloader codebase\n\n### Project Structure (structure.md)\n\nThe implementation follows the existing project organization:\n- New modules are added to the `zlibrary_downloader/` package\n- Test files mirror the source structure in `tests/`\n- Single credential: Configuration in `.env` file (backward compatible)\n- Multiple credentials: Configuration in `zlibrary_credentials.toml` file (new, scalable format)\n- State files are stored in the project root (configurable)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **zlibrary_downloader/client.py (Zlibrary class)**: Existing Z-Library API client will be wrapped by ClientPool for credential-aware operations\n- **zlibrary_downloader/cli.py**: Existing CLI interface will be extended to support credential management without breaking existing functionality\n- **python-dotenv library**: Already used for `.env` file parsing, will continue to support single-credential backward compatibility\n- **TOML parsing (tomllib/tomli)**: Will be used for multi-credential configuration (Python 3.11+ has built-in tomllib, older versions use tomli)\n- **Existing error handling patterns**: Will be extended to handle credential-specific errors\n\n### Integration Points\n\n- **CLI Entry Point (cli.py)**: Will be modified to initialize CredentialManager and ClientPool instead of direct Zlibrary client\n- **Configuration Files**:\n  - `.env` for single-credential (backward compatible)\n  - `zlibrary_credentials.toml` for multi-credential (new, scalable format)\n- **Z-Library API**: All credential types (email/password and remix tokens) are already supported by the existing Zlibrary client\n\n## Architecture\n\nThe design introduces a layered architecture with clear separation of concerns:\n\n### Modular Design Principles\n\n- **Single File Responsibility**:\n  - `credential.py` handles credential data modeling only\n  - `credential_manager.py` handles credential lifecycle and rotation logic\n  - `rotation_state.py` handles state persistence only\n  - `client_pool.py` manages Zlibrary client instances with credential awareness\n\n- **Component Isolation**: Each component can be tested independently with minimal mocking\n\n- **Service Layer Separation**:\n  - Data layer: Credential data model and state persistence\n  - Business logic: CredentialManager handles rotation rules\n  - Client layer: ClientPool manages API client instances\n  - Presentation layer: CLI displays status and handles user interaction\n\n```mermaid\ngraph TD\n    A[CLI Interface cli.py] --> B[ClientPool]\n    B --> C[CredentialManager]\n    C --> D[RotationState]\n    C --> E[Credential Models]\n    B --> F[Zlibrary API Client]\n    F --> G[Z-Library API]\n\n    style A fill:#e1f5e1\n    style B fill:#fff4e6\n    style C fill:#fff4e6\n    style D fill:#e6f3ff\n    style E fill:#e6f3ff\n    style F fill:#ffe6e6\n    style G fill:#f0f0f0\n```\n\n## Components and Interfaces\n\n### Component 1: Credential Data Model\n\n- **File**: `zlibrary_downloader/credential.py`\n- **Purpose**: Represent individual credential with status tracking\n- **Interfaces**:\n  ```python\n  class CredentialStatus(Enum):\n      VALID = \"valid\"\n      INVALID = \"invalid\"\n      EXHAUSTED = \"exhausted\"\n\n  @dataclass\n  class Credential:\n      identifier: str\n      email: Optional[str] = None\n      password: Optional[str] = None\n      remix_userid: Optional[str] = None\n      remix_userkey: Optional[str] = None\n      status: CredentialStatus = CredentialStatus.VALID\n      downloads_left: int = -1\n      last_used: Optional[datetime] = None\n      last_validated: Optional[datetime] = None\n\n      def is_available() -> bool\n      def to_dict() -> dict\n      @staticmethod\n      def from_dict(data: dict) -> Credential\n  ```\n- **Dependencies**: Python standard library (dataclasses, enum, datetime)\n- **Reuses**: None (foundational component)\n\n### Component 2: Credential Manager\n\n- **File**: `zlibrary_downloader/credential_manager.py`\n- **Purpose**: Manage credential loading, validation, and rotation logic\n- **Interfaces**:\n  ```python\n  class CredentialManager:\n      def __init__(self, state_file: str = \".zlibrary_rotation_state\", config_file: str = \"zlibrary_credentials.toml\")\n      def load_credentials() -> List[Credential]\n      def validate_credential(cred: Credential, zlibrary_client: Zlibrary) -> bool\n      def get_current() -> Credential\n      def rotate() -> Credential\n      def update_downloads_left(identifier: str, limit: int) -> None\n      def get_available() -> List[Credential]\n      def save_state() -> None\n      def load_state() -> None\n  ```\n- **Dependencies**: Credential, RotationState, tomllib/tomli (TOML parsing), os.environ (dotenv for backward compatibility)\n- **Reuses**: Existing Zlibrary client for credential validation via getProfile()\n\n### Component 3: Rotation State\n\n- **File**: `zlibrary_downloader/rotation_state.py`\n- **Purpose**: Handle persistent storage of rotation state\n- **Interfaces**:\n  ```python\n  class RotationState:\n      def __init__(self, state_file: str)\n      def save(self, current_index: int, credentials_status: Dict[str, dict]) -> None\n      def load() -> Tuple[int, Dict[str, dict]]\n      def exists() -> bool\n      def validate() -> bool\n  ```\n- **Dependencies**: json, pathlib\n- **Reuses**: None (independent state management)\n\n### Component 4: Client Pool\n\n- **File**: `zlibrary_downloader/client_pool.py`\n- **Purpose**: Cache Zlibrary client instances and provide credential-aware client access\n- **Interfaces**:\n  ```python\n  class ZlibraryClientPool:\n      def __init__(self, credential_manager: CredentialManager)\n      def get_current_client() -> Zlibrary\n      def rotate_client() -> Zlibrary\n      def validate_all() -> Dict[str, bool]\n      def refresh_client(identifier: str) -> Zlibrary\n  ```\n- **Dependencies**: CredentialManager, Zlibrary client\n- **Reuses**: Existing Zlibrary client class for API operations\n\n## Data Models\n\n### Credential Model\n\n```python\n{\n    \"identifier\": \"user@example.com\",  # Email or user ID for identification\n    \"email\": \"user@example.com\",       # For email/password auth (optional)\n    \"password\": \"password123\",         # For email/password auth (optional)\n    \"remix_userid\": \"123456\",          # For remix token auth (optional)\n    \"remix_userkey\": \"remix_key\",      # For remix token auth (optional)\n    \"status\": \"valid\",                 # VALID, INVALID, or EXHAUSTED\n    \"downloads_left\": 10,              # Remaining download quota\n    \"last_used\": \"2024-10-16T12:30:45Z\",      # ISO datetime\n    \"last_validated\": \"2024-10-16T10:00:00Z\"  # ISO datetime\n}\n```\n\n### Rotation State Model\n\n```json\n{\n    \"current_index\": 1,\n    \"last_rotation\": \"2024-10-16T12:30:45Z\",\n    \"credentials_status\": {\n        \"user1@example.com\": {\n            \"last_used\": \"2024-10-16T12:30:45Z\",\n            \"downloads_left\": 8,\n            \"status\": \"valid\"\n        },\n        \"user2@example.com\": {\n            \"last_used\": \"2024-10-16T12:15:30Z\",\n            \"downloads_left\": 0,\n            \"status\": \"exhausted\"\n        }\n    }\n}\n```\n\n### Configuration File Formats\n\n#### Single Credential - .env (Backward Compatible)\n```env\nZLIBRARY_EMAIL=user@example.com\nZLIBRARY_PASSWORD=password123\n```\n\nOr with remix tokens:\n```env\nZLIBRARY_REMIX_USERID=123456789\nZLIBRARY_REMIX_USERKEY=remix_token_key\n```\n\n#### Multiple Credentials - zlibrary_credentials.toml (New, Scalable)\n\n```toml\n# Z-Library Credentials Configuration\n# Support unlimited accounts with structured data format\n\n# Optional: Override default state file location\nstate_file = \".zlibrary_rotation_state\"\n\n# Credentials array - each entry represents one account\n[[credentials]]\nname = \"Primary Account\"\nemail = \"user1@example.com\"\npassword = \"password1\"\nenabled = true\n\n[[credentials]]\nname = \"Secondary Account\"\nemail = \"user2@example.com\"\npassword = \"password2\"\nenabled = true\n\n[[credentials]]\nname = \"Backup Account - Remix Token\"\nremix_userid = \"123456789\"\nremix_userkey = \"your_remix_token_key_here\"\nenabled = true\n\n# You can disable accounts without deleting them\n[[credentials]]\nname = \"Disabled Account\"\nemail = \"user3@example.com\"\npassword = \"password3\"\nenabled = false\n```\n\n**Benefits of TOML format**:\n- Unlimited credentials (not limited to numbered indexes)\n- More readable and maintainable than .env\n- Supports comments for documentation\n- Structured data with clear sections\n- Can enable/disable accounts without deletion\n- Native Python support (Python 3.11+ built-in, tomli for older versions)\n- Industry standard for Python configuration (like pyproject.toml)\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Credentials During Startup**\n   - **Handling**: Log warning with credential identifier (not password), mark credential as INVALID, continue with remaining credentials\n   - **User Impact**: User sees warning message: \"Credential 'user@example.com' failed validation. Skipping.\"\n\n2. **All Credentials Invalid**\n   - **Handling**: Raise exception, display clear error message, exit gracefully\n   - **User Impact**: User sees: \"Error: No valid credentials available. Please check your .env configuration.\"\n\n3. **Credential Exhausted During Operation**\n   - **Handling**: Skip to next available credential, log rotation event, continue operation\n   - **User Impact**: User sees: \"Account 'user1@example.com' exhausted. Rotating to next account...\"\n\n4. **State File Corrupted**\n   - **Handling**: Log warning, delete corrupted state, initialize fresh state\n   - **User Impact**: User sees: \"Warning: Rotation state corrupted. Starting fresh rotation cycle.\"\n\n5. **No Available Credentials (All Exhausted)**\n   - **Handling**: Return error to user, do not perform operation\n   - **User Impact**: User sees: \"Error: All accounts have reached their download limits. Please wait or add more accounts.\"\n\n6. **Network Error During Validation**\n   - **Handling**: Retry up to 2 times, if still failing mark as temporarily invalid\n   - **User Impact**: User sees: \"Warning: Could not validate 'user@example.com' due to network issues. Will retry.\"\n\n## Testing Strategy\n\n### Unit Testing\n\n- **credential.py**: Test Credential data model serialization/deserialization, status checks, validation logic\n- **credential_manager.py**: Test credential loading (both formats), rotation logic, filtering, state management\n- **rotation_state.py**: Test state save/load, corruption handling, file permissions\n- **client_pool.py**: Test client caching, rotation, validation, refresh logic\n- Target: >80% code coverage for all new modules\n\n### Integration Testing\n\n- **Multi-credential authentication**: Test login with 3 different accounts (email/password and remix)\n- **Search with rotation**: Perform 5 searches and verify rotation occurs after each\n- **Download with rotation**: Perform 5 downloads and verify rotation and limit tracking\n- **Fallback mechanisms**: Simulate credential failure and verify fallback to next credential\n- **State persistence**: Restart application and verify rotation state is restored\n\n### End-to-End Testing\n\n- **Full workflow with 2-3 accounts**: Configure multiple accounts, perform 10+ operations, verify seamless rotation\n- **Credential exhaustion scenarios**: Exhaust one account, verify automatic skip to next\n- **Error recovery**: Simulate various error conditions and verify graceful handling\n- **Backward compatibility**: Test with single-credential `.env` format\n\n### Performance Tests\n\n- **Rotation overhead**: Measure time added by rotation logic (target: <100ms)\n- **State file I/O**: Measure state save/load performance (target: <50ms)\n- **Client caching efficiency**: Verify no repeated authentication for same credential\n\n## Integration with Existing Code\n\n### Changes to cli.py\n\n1. **load_credentials() function**:\n   - Replace direct environment variable reading with CredentialManager.load_credentials()\n   - Auto-detect configuration format:\n     - Check for `zlibrary_credentials.toml` (multi-credential)\n     - Fall back to `.env` (single-credential, backward compatible)\n\n2. **initialize_zlibrary() function**:\n   - Replace direct Zlibrary client creation with ClientPool.get_current_client()\n   - Add credential status display on startup\n\n3. **search_books() function**:\n   - Add ClientPool.rotate_client() call after successful search\n   - Update to use current client from pool\n\n4. **download_book() function**:\n   - Add ClientPool.rotate_client() call after successful download\n   - Update download limit tracking via CredentialManager\n   - Add error handling for exhausted credentials\n\n5. **New display_credential_status() function**:\n   - Show summary of available accounts and their status\n   - Display remaining downloads per account\n\n### New Configuration Detection Logic\n\n```python\ndef detect_credential_source() -> str:\n    \"\"\"Detect configuration source for credentials.\"\"\"\n    # Check for TOML config file (multi-credential)\n    if Path(\"zlibrary_credentials.toml\").exists():\n        return \"toml\"\n    # Fall back to .env (single-credential, backward compatible)\n    elif os.getenv(\"ZLIBRARY_EMAIL\") or os.getenv(\"ZLIBRARY_REMIX_USERID\"):\n        return \"env\"\n    else:\n        raise ValueError(\"No Z-Library credentials found. Create .env or zlibrary_credentials.toml\")\n\ndef load_from_toml(config_file: str = \"zlibrary_credentials.toml\") -> List[Credential]:\n    \"\"\"Load credentials from TOML file.\"\"\"\n    try:\n        # Python 3.11+\n        import tomllib\n    except ImportError:\n        # Python 3.6-3.10\n        import tomli as tomllib\n\n    with open(config_file, \"rb\") as f:\n        config = tomllib.load(f)\n\n    credentials = []\n    for cred_data in config.get(\"credentials\", []):\n        if not cred_data.get(\"enabled\", True):\n            continue  # Skip disabled credentials\n\n        # Create Credential object from TOML data\n        # ... (implementation details)\n\n    return credentials\n\ndef load_from_env() -> List[Credential]:\n    \"\"\"Load single credential from .env file (backward compatible).\"\"\"\n    # ... (existing implementation)\n```\n\n## Backward Compatibility\n\n- **Single credential** `.env` format (`ZLIBRARY_EMAIL` + `ZLIBRARY_PASSWORD`) continues to work unchanged\n- **Auto-detection** of configuration source ensures seamless transition:\n  - If `zlibrary_credentials.toml` exists → use TOML (multi-credential)\n  - Otherwise → fall back to `.env` (single-credential)\n- **No breaking changes** to CLI interface or command-line arguments\n- **Existing scripts** and automation continue to work without modification\n- **State file** is optional - system works without it (just starts from index 0)\n- **Migration path**: Users can move from `.env` to TOML at their convenience\n\n## Security Considerations\n\n- **Credential Logging**: Never log passwords or API keys. Only log identifiers (email/user ID) for debugging\n- **Error Message Sanitization**: Ensure error messages do not expose credentials\n- **File Permissions**:\n  - TOML config file: Set chmod 600 on Unix systems, warn on Windows\n  - State file: Set chmod 600 on Unix systems\n- **Input Validation**: Validate all credential data before use\n- **Memory Security**: Clear credential data from memory when no longer needed (future enhancement)\n- **TOML File Security**: Add `zlibrary_credentials.toml` to `.gitignore` to prevent accidental commits\n\n## Performance Considerations\n\n- **Client Caching**: Cache Zlibrary client instances to avoid repeated authentication (reduces latency by ~500ms per operation)\n- **Lazy Validation**: Only validate credentials when first used, not all at startup (reduces startup time)\n- **State File Optimization**: Only write state file when rotation occurs, not on every operation\n- **Async Validation**: Consider async validation for large credential sets (10+) in future enhancement\n\n## Workflow Diagrams\n\n### Startup Flow\n\n```\nApplication Start\n    ↓\nDetect configuration source\n    ├─ zlibrary_credentials.toml exists? → Load TOML (multi-credential)\n    └─ Otherwise → Load .env (single-credential)\n    ↓\nCreate CredentialManager\n    ↓\nLoad credentials from detected source\n    ↓\nLoad previous rotation state (if exists)\n    ↓\nInitialize ClientPool\n    ↓\nValidate first credential (lazy)\n    ↓\nDisplay credential summary\n    ↓\nReady for operations\n```\n\n### Operation Flow\n\n```\nUser initiates search/download\n    ↓\nClientPool.get_current_client()\n    ↓\nCheck credential status\n    ├─ Valid → Use client\n    ├─ Exhausted → Rotate, retry\n    └─ Invalid → Rotate, retry\n    ↓\nExecute operation\n    ↓\nOn success:\n    ├─ Update download count\n    ├─ Rotate to next credential\n    └─ Save state\n    ↓\nOn failure:\n    ├─ Log error\n    ├─ Rotate to next credential\n    └─ Retry (up to N times)\n```\n\n### Rotation Flow\n\n```\nCredentialManager.rotate()\n    ↓\nIncrement current_index\n    ↓\nCheck if index >= len(credentials)\n    ├─ Yes → Wrap to 0\n    └─ No → Continue\n    ↓\nGet credential at current_index\n    ↓\nCheck if credential.is_available()\n    ├─ Yes → Return credential\n    └─ No → Increment index, retry\n    ↓\nIf all exhausted → Raise exception\n    ↓\nUpdate rotation state\n    ↓\nSave state to file\n```\n",
  "fileStats": {
    "size": 17907,
    "lines": 496,
    "lastModified": "2025-10-16T14:51:01.149Z"
  },
  "comments": []
}